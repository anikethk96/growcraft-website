<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Growcraft - AI Analytics Platform</title>
    <link rel="icon" type="image/png" href="IconOnly_Transparent_NoBuffer.png">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav id="navbar">
        <div class="nav-container">
            <a href="#" class="nav-logo">
                <img src="FullLogo_Transparent_NoBuffer.png" alt="Growcraft Logo" />
            </a>
            
            <ul class="nav-menu" id="nav-menu">
                <li class="nav-item">
                    <a href="#home" class="nav-link">Home</a>
                </li>
                <li class="nav-item">
                    <a href="#problems" class="nav-link">Problems</a>
                </li>
                <li class="nav-item">
                    <a href="#solution" class="nav-link">Solution</a>
                </li>
                <li class="nav-item">
                    <a href="about.html" class="nav-link">About</a>
                </li>
                <li class="nav-item">
                    <a href="#contact" class="nav-link">Contact</a>
                </li>
                <li class="nav-item nav-cta">
                    <a href="#" class="btn btn-primary">Get Started</a>
                </li>
            </ul>
            
            <div class="hamburger" id="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <section class="hero" id="home">
        <div class="vector-network">
            <svg id="networkSvg" xmlns="http://www.w3.org/2000/svg">
                </svg>
        </div>
        
        <div id="networkNodes"></div>
        
        <div class="gradient-orb"></div>
        <div class="grid-overlay"></div>
        
        <div class="hero-content">
            <h1 class="hero-title gradient-text">AI Analytics Platform</h1>
            <p class="hero-subtitle">
                Cooking up a hyper-connected swarm of AI Agents for Retail Analytics
            </p>
            <div class="hero-buttons">
                <a href="#" class="btn btn-primary">Start Free Trial</a>
                <a href="about.html" class="btn btn-secondary">Learn About Our Mission â†’</a>
            </div>
        </div>
    </section>

    <section class="problem-section" id="problems">
        <div class="container">
            <h2 class="section-title">The Challenges We Solve</h2>
            <p class="text-center" style="max-width: 800px; margin: 0 auto 3rem;">
                60-70% of all retail analytics tasks are repetitive but contextual, requiring analysts to use multiple tools to execute (SQL for data query, BI tools for model building, PPT for sharing etc).
            </p>
            
            <div class="problems-grid">
                <div class="problem-card">
                    <div class="problem-number">1</div>
                    <h3 class="problem-title">Fragmented Solutions</h3>
                    <p class="problem-description">
                        Existing SaaS solutions are highly fragmented, offering piece-meal solutions to departmental tasks. Analysts usually depend on multiple tools and vendors.
                    </p>
                </div>
                
                <div class="problem-card">
                    <div class="problem-number">2</div>
                    <h3 class="problem-title">Siloed Operations</h3>
                    <p class="problem-description">
                        Current retail operations are notoriously siloed, leading to inefficiencies and often resulting in money left on the table.
                    </p>
                </div>
                
                <div class="problem-card">
                    <div class="problem-number">3</div>
                    <h3 class="problem-title">Technical Debt</h3>
                    <p class="problem-description">
                        Legacy SaaS companies offering "AI-Powered" solutions have serious technical-debt hindering truly AI-native solutions.
                    </p>
                </div>
            </div>
        </div>
    </section>

    <section class="solution-section" id="solution">
        <div class="container">
            <div class="solution-content">
                <h2 class="section-title gradient-text">Our Solution</h2>
                <div class="solution-highlight">
                    <p>
                        Agent swarm model not only ensures true contextual automation of individual repetitive tasks but also ensures a seamless integration to meet a higher collective goal for the business.
                    </p>
                </div>
                <a href="about.html" class="btn btn-primary">Learn More About Our Approach</a>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2024 Growcraft. All rights reserved.</p>
        </div>
    </footer>

    <script>
        // Hamburger Menu Toggle
        const hamburger = document.getElementById('hamburger');
        const navMenu = document.getElementById('nav-menu');
        const body = document.body;
        const navLinks = document.querySelectorAll('.nav-link');

        hamburger.addEventListener('click', () => {
            hamburger.classList.toggle('active');
            navMenu.classList.toggle('active');
            body.classList.toggle('menu-open');
        });

        // Close menu when clicking nav links (mobile)
        navLinks.forEach(link => {
            link.addEventListener('click', () => {
                hamburger.classList.remove('active');
                navMenu.classList.remove('active');
                body.classList.remove('menu-open');
            });
        });

        // Add scroll effect to navigation
        window.addEventListener('scroll', () => {
            const navbar = document.getElementById('navbar');
            if (window.scrollY > 50) {
                navbar.classList.add('scrolled');
            } else {
                navbar.classList.remove('scrolled');
            }
        });

        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const navHeight = document.getElementById('navbar').offsetHeight;
                    const targetPosition = target.offsetTop - navHeight;
                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Vector Network Animation
        function createVectorNetwork() {
            const svg = document.getElementById('networkSvg');
            const nodesContainer = document.getElementById('networkNodes');
            const hero = document.querySelector('.hero');
            
            // Clear existing content
            svg.innerHTML = '';
            nodesContainer.innerHTML = '';
            
            const width = hero.offsetWidth;
            const height = hero.offsetHeight;
            
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            // Create network nodes (connection points)
            const nodes = [];
            const nodeCount = Math.min(12, Math.floor(width / 100)); // Responsive node count
            
            for (let i = 0; i < nodeCount; i++) {
                const node = {
                    x: Math.random() * width * 0.8 + width * 0.1, // Keep nodes away from edges
                    y: Math.random() * height * 0.8 + height * 0.1,
                    vx: (Math.random() - 0.5) * 0.5, // Slow movement
                    vy: (Math.random() - 0.5) * 0.5,
                    connections: []
                };
                nodes.push(node);
                
                // Create visual node element
                const nodeElement = document.createElement('div');
                nodeElement.className = 'network-node';
                if (Math.random() > 0.7) nodeElement.classList.add('pulse');
                nodeElement.style.left = node.x + 'px';
                nodeElement.style.top = node.y + 'px';
                nodesContainer.appendChild(nodeElement);
            }
            
            // Create connections between nearby nodes
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const distance = Math.sqrt(
                        Math.pow(nodes[i].x - nodes[j].x, 2) + 
                        Math.pow(nodes[i].y - nodes[j].y, 2)
                    );
                    
                    // Connect nodes that are close enough
                    if (distance < Math.min(width, height) * 0.25) {
                        nodes[i].connections.push(j);
                        
                        // Create SVG line
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', nodes[i].x);
                        line.setAttribute('y1', nodes[i].y);
                        line.setAttribute('x2', nodes[j].x);
                        line.setAttribute('y2', nodes[j].y);
                        line.setAttribute('stroke', `rgba(99, 102, 241, ${0.1 + Math.random() * 0.2})`);
                        line.setAttribute('stroke-width', Math.random() * 1.5 + 0.5);
                        line.setAttribute('stroke-dasharray', '5,10');
                        line.setAttribute('stroke-dashoffset', '1000');
                        
                        // Animate line drawing
                        line.style.animation = `drawLine ${2 + Math.random() * 3}s ease-in-out infinite alternate`;
                        line.style.animationDelay = Math.random() * 2 + 's';
                        
                        svg.appendChild(line);
                    }
                }
            }
            
            // Add some random vector lines for extra AI feel
            for (let i = 0; i < 8; i++) {
                const startX = Math.random() * width;
                const startY = Math.random() * height;
                const length = Math.random() * 200 + 100;
                const angle = Math.random() * Math.PI * 2;
                const endX = startX + Math.cos(angle) * length;
                const endY = startY + Math.sin(angle) * length;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX);
                line.setAttribute('y1', startY);
                line.setAttribute('x2', endX);
                line.setAttribute('y2', endY);
                line.setAttribute('stroke', `rgba(14, 165, 233, ${0.05 + Math.random() * 0.1})`);
                line.setAttribute('stroke-width', Math.random() * 1 + 0.5);
                line.setAttribute('stroke-dasharray', '2,8');
                line.setAttribute('stroke-dashoffset', '1000');
                
                line.style.animation = `drawLine ${3 + Math.random() * 4}s ease-in-out infinite alternate`;
                line.style.animationDelay = Math.random() * 3 + 's';
                
                svg.appendChild(line);
            }
            
            // Animate nodes (subtle movement)
            function animateNodes() {
                const nodeElements = document.querySelectorAll('.network-node');
                nodes.forEach((node, index) => {
                    // Update position
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    // Bounce off edges
                    if (node.x <= 0 || node.x >= width) node.vx *= -1;
                    if (node.y <= 0 || node.y >= height) node.vy *= -1;
                    
                    // Keep nodes in bounds
                    node.x = Math.max(0, Math.min(width, node.x));
                    node.y = Math.max(0, Math.min(height, node.y));
                    
                    // Update visual position
                    if (nodeElements[index]) {
                        nodeElements[index].style.left = node.x + 'px';
                        nodeElements[index].style.top = node.y + 'px';
                    }
                });
                
                requestAnimationFrame(animateNodes);
            }
            
            // Start subtle node animation
            animateNodes();
        }
        
        // Initialize vector network
        createVectorNetwork();
        
        // Recreate network on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(createVectorNetwork, 500);
        });

        // Animate elements on scroll
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, observerOptions);

        // Observe all cards
        document.querySelectorAll('.problem-card').forEach(card => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(20px)';
            card.style.transition = 'all 0.6s ease-out';
            observer.observe(card);
        });
    </script>
</body>
</html>
